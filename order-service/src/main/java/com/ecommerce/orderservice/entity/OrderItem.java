package com.ecommerce.orderservice.entity;

// Import JPA annotations for entity mapping
import jakarta.persistence.*;

// Import Lombok annotations to reduce boilerplate
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

// Import BigDecimal for precise monetary calculations
import java.math.BigDecimal;

// Import time class for timestamps
import java.time.LocalDateTime;

/**
 * OrderItem Entity
 *
 * Represents a single line item in an order.
 * Each order can have multiple order items (products).
 *
 * Example:
 * Order #123 contains:
 * - OrderItem 1: 2 x Laptop @ $999.99 = $1999.98
 * - OrderItem 2: 1 x Mouse @ $29.99 = $29.99
 * - Total: $2029.97
 *
 * Why separate OrderItem from Order?
 * -----------------------------------
 * 1. One-to-Many Relationship: One order contains many items
 * 2. Normalization: Avoids data duplication
 * 3. Flexibility: Easy to add/remove items
 * 4. Queryability: Can query by product, price range, etc.
 *
 * Why store product details instead of just product_id?
 * ------------------------------------------------------
 * Product details might change over time:
 * - Price changes: Product costs $100 now, $120 tomorrow
 * - Name changes: Product renamed
 * - Product deleted: Product removed from catalog
 *
 * We need to preserve order history exactly as it was at purchase time!
 *
 * Solution: Store snapshot of product details
 * - product_id: Reference for lookups (can be null if product deleted)
 * - product_name: Name at time of purchase
 * - product_price: Price at time of purchase
 *
 * This ensures order history remains accurate even if products change.
 *
 * Database Table: order_items
 * Columns: id, order_id, product_id, product_name, product_price, quantity, subtotal, created_at, updated_at
 */

// @Entity marks this class as a JPA entity (maps to database table)
@Entity

// @Table specifies table name and database constraints
@Table(name = "order_items", indexes = {
        // Index on order_id for fast lookups
        // Query: "Find all items for order #123"
        // Without index: Scans entire table
        // With index: Direct lookup
        @Index(name = "idx_order_id", columnList = "order_id"),

        // Index on product_id for reporting
        // Query: "Which orders contain product #456?"
        // Useful for:
        // - Product sales reports
        // - Finding affected orders when product recalled
        // - Analytics on product popularity
        @Index(name = "idx_product_id", columnList = "product_id")
})

// @Data (Lombok) generates:
// - Getters for all fields
// - Setters for all non-final fields
// - toString() method
// - equals() and hashCode() methods
@Data

// @NoArgsConstructor (Lombok) generates no-argument constructor
// Required by JPA for entity instantiation
@NoArgsConstructor

// @AllArgsConstructor (Lombok) generates constructor with all fields
// Useful for testing and creating instances
@AllArgsConstructor
public class OrderItem {

    /**
     * Primary Key
     *
     * Unique identifier for this order item.
     * Auto-generated by database.
     */
    @Id  // Marks this as primary key
    @GeneratedValue(strategy = GenerationType.IDENTITY)  // Auto-increment
    private Long id;

    /**
     * Order Reference
     *
     * Many-to-One relationship with Order entity.
     * Multiple OrderItems belong to one Order.
     *
     * @ManyToOne:
     * - Many order items can belong to one order
     * - Defines parent-child relationship
     *
     * @JoinColumn:
     * - Specifies foreign key column name
     * - order_id column stores the ID of the parent order
     * - nullable = false: Order item must belong to an order
     *
     * Fetch type LAZY:
     * - When loading OrderItem, don't automatically load Order
     * - Load Order only when explicitly accessed
     * - Improves performance (fewer database queries)
     * - Example: orderItem.getOrder().getOrderNumber() triggers load
     *
     * Why LAZY vs EAGER?
     * - LAZY: Load on demand (better performance)
     * - EAGER: Load immediately (more memory, more queries)
     * - Default for @ManyToOne is EAGER, we override to LAZY
     */
    @ManyToOne(fetch = FetchType.LAZY)  // Many items belong to one order
    @JoinColumn(name = "order_id", nullable = false)  // Foreign key column
    private Order order;

    /**
     * Product ID
     *
     * Reference to the product in Product Service.
     *
     * Why nullable = true?
     * - Product might be deleted from catalog later
     * - We still want to preserve order history
     * - Product details stored in product_name and product_price
     *
     * This is a soft reference:
     * - If product exists: Can link to it for details
     * - If product deleted: Order item still has name and price
     *
     * Not a foreign key because:
     * - Product exists in different database (Product Service)
     * - Cross-database foreign keys not supported
     * - Microservices are loosely coupled
     */
    @Column(name = "product_id", nullable = true)
    private Long productId;

    /**
     * Product Name (Snapshot)
     *
     * Name of the product at time of purchase.
     * Preserved even if product renamed or deleted.
     *
     * Example:
     * - 2024-01-15: Customer buys "MacBook Pro 2023"
     * - 2024-02-01: Product renamed to "MacBook Pro M3"
     * - Order history still shows "MacBook Pro 2023" (accurate!)
     */
    @Column(name = "product_name", nullable = false, length = 255)
    private String productName;

    /**
     * Product Price (Snapshot)
     *
     * Price per unit at time of purchase.
     * Preserved even if product price changes later.
     *
     * Why BigDecimal for price?
     * --------------------------
     * Bad: double price = 29.99;
     * Problem: 0.1 + 0.2 = 0.30000000000000004 (rounding errors!)
     *
     * Good: BigDecimal price = new BigDecimal("29.99");
     * Benefits:
     * - Exact decimal precision
     * - No rounding errors
     * - Essential for money calculations
     *
     * Database Mapping:
     * - precision = 10: Total digits (e.g., 12345.67 has 7 digits)
     * - scale = 2: Decimal places (e.g., .67 has 2 decimal places)
     * - Supports values up to: 99,999,999.99
     * - Column type: DECIMAL(10,2)
     *
     * Example:
     * - 2024-01-15: Product costs $999.99
     * - 2024-02-01: Product price increased to $1099.99
     * - Order shows $999.99 (price when customer purchased)
     */
    @Column(name = "product_price", nullable = false, precision = 10, scale = 2)
    private BigDecimal productPrice;

    /**
     * Quantity
     *
     * Number of units of this product in the order.
     *
     * Constraints:
     * - nullable = false: Must have a quantity
     * - Business validation: Should be > 0
     *
     * Example:
     * - Customer adds 2 laptops to cart
     * - quantity = 2
     */
    @Column(name = "quantity", nullable = false)
    private Integer quantity;

    /**
     * Subtotal
     *
     * Total price for this line item.
     * Calculated as: productPrice Ã— quantity
     *
     * Example:
     * - productPrice = $999.99
     * - quantity = 2
     * - subtotal = $1999.98
     *
     * Why store calculated value?
     * ---------------------------
     * Option 1: Calculate on-the-fly
     * - subtotal = productPrice * quantity
     * - Pros: Always accurate, no storage
     * - Cons: Recalculate every time, potential rounding differences
     *
     * Option 2: Store in database (our approach)
     * - Calculate once when creating order item
     * - Store in database
     * - Pros: Fast retrieval, consistent value, historical accuracy
     * - Cons: Uses storage, must update if quantity changes
     *
     * We choose option 2 for:
     * - Performance (no calculation needed on every read)
     * - Historical accuracy (preserves exact amount charged)
     * - Consistency (same value every time)
     */
    @Column(name = "subtotal", nullable = false, precision = 10, scale = 2)
    private BigDecimal subtotal;

    /**
     * Created Timestamp
     *
     * When this order item was created.
     * Set automatically when entity is first saved.
     *
     * @Column settings:
     * - nullable = false: Must have creation time
     * - updatable = false: Cannot be changed after creation
     *
     * Uses @PrePersist callback (see onCreate method below)
     */
    @Column(name = "created_at", nullable = false, updatable = false)
    private LocalDateTime createdAt;

    /**
     * Updated Timestamp
     *
     * When this order item was last modified.
     * Updated automatically on every save.
     *
     * @Column settings:
     * - nullable = false: Must have update time
     * - updatable = true: Can be changed (this is the default)
     *
     * Uses @PreUpdate callback (see onUpdate method below)
     */
    @Column(name = "updated_at", nullable = false)
    private LocalDateTime updatedAt;

    /**
     * Pre-Persist Callback
     *
     * Executed automatically BEFORE entity is first saved to database.
     * Sets creation and update timestamps to current time.
     *
     * Lifecycle:
     * 1. Create new OrderItem: OrderItem item = new OrderItem();
     * 2. Set properties: item.setProductName("Laptop");
     * 3. Save to database: orderItemRepository.save(item);
     * 4. @PrePersist triggers: onCreate() is called
     * 5. Timestamps set: createdAt and updatedAt = now
     * 6. INSERT SQL executed with timestamp values
     *
     * Why use @PrePersist vs setting manually?
     * - Automatic: No need to remember to set timestamps
     * - Consistent: Same timestamp logic everywhere
     * - Reliable: Cannot forget or set wrong value
     */
    @PrePersist
    protected void onCreate() {
        // Get current date and time
        LocalDateTime now = LocalDateTime.now();

        // Set creation timestamp (first time only)
        createdAt = now;

        // Set update timestamp (will be updated on every save)
        updatedAt = now;
    }

    /**
     * Pre-Update Callback
     *
     * Executed automatically BEFORE entity is updated in database.
     * Updates the updatedAt timestamp to current time.
     *
     * Lifecycle:
     * 1. Load existing OrderItem: OrderItem item = repo.findById(1);
     * 2. Modify property: item.setQuantity(3);
     * 3. Save changes: orderItemRepository.save(item);
     * 4. @PreUpdate triggers: onUpdate() is called
     * 5. Update timestamp: updatedAt = now
     * 6. UPDATE SQL executed with new timestamp
     *
     * Note: createdAt is NOT updated (updatable = false)
     */
    @PreUpdate
    protected void onUpdate() {
        // Set update timestamp to current time
        // This happens every time entity is saved (except first time)
        updatedAt = LocalDateTime.now();
    }

    // =========================================================================
    // Business Logic Methods (Optional - can be added in Service layer)
    // =========================================================================
    //
    // /**
    //  * Calculate subtotal from price and quantity
    //  * Called before saving order item
    //  */
    // public void calculateSubtotal() {
    //     this.subtotal = this.productPrice.multiply(
    //         new BigDecimal(this.quantity)
    //     );
    // }
    //
    // /**
    //  * Check if order item is for a specific product
    //  */
    // public boolean isForProduct(Long productId) {
    //     return this.productId != null &&
    //            this.productId.equals(productId);
    // }
    //
    // =========================================================================
    // Example Usage
    // =========================================================================
    //
    // // Create order item
    // OrderItem item = new OrderItem();
    // item.setOrder(existingOrder);
    // item.setProductId(456L);
    // item.setProductName("Wireless Mouse");
    // item.setProductPrice(new BigDecimal("29.99"));
    // item.setQuantity(2);
    // item.setSubtotal(new BigDecimal("59.98"));
    //
    // // Save (onCreate() is called automatically)
    // orderItemRepository.save(item);
    //
    // // Update quantity later
    // item.setQuantity(3);
    // item.setSubtotal(new BigDecimal("89.97"));
    // orderItemRepository.save(item);  // onUpdate() is called
    //
    // =========================================================================
    // Database Schema
    // =========================================================================
    //
    // CREATE TABLE order_items (
    //     id BIGINT AUTO_INCREMENT PRIMARY KEY,
    //     order_id BIGINT NOT NULL,
    //     product_id BIGINT,
    //     product_name VARCHAR(255) NOT NULL,
    //     product_price DECIMAL(10,2) NOT NULL,
    //     quantity INT NOT NULL,
    //     subtotal DECIMAL(10,2) NOT NULL,
    //     created_at DATETIME NOT NULL,
    //     updated_at DATETIME NOT NULL,
    //     FOREIGN KEY (order_id) REFERENCES orders(id),
    //     INDEX idx_order_id (order_id),
    //     INDEX idx_product_id (product_id)
    // );
}
