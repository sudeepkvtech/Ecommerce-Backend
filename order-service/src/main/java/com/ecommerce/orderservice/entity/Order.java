package com.ecommerce.orderservice.entity;

// Import JPA annotations
import jakarta.persistence.*;

// Import Lombok annotations
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

// Import BigDecimal for monetary values
import java.math.BigDecimal;

// Import time classes
import java.time.LocalDateTime;

// Import List for order items
import java.util.ArrayList;
import java.util.List;

/**
 * Order Entity
 *
 * Represents a customer order in the e-commerce system.
 * An order contains multiple order items (products) and tracks the order lifecycle.
 *
 * Relationships:
 * - User Service: userId references user who placed the order
 * - Address: shippingAddressId references delivery address
 * - OrderItem: One order has many order items (products)
 *
 * Database Table: orders
 * Columns: id, user_id, order_number, status, total_amount, shipping_address_id,
 *          payment_method, created_at, updated_at
 *
 * Order Lifecycle:
 * 1. Customer adds products to cart
 * 2. Customer clicks "Place Order"
 * 3. Order created with status PENDING
 * 4. Payment processed → status CONFIRMED
 * 5. Warehouse prepares order → status PROCESSING
 * 6. Order shipped → status SHIPPED
 * 7. Order delivered → status DELIVERED
 *
 * Alternative: Order cancelled at any point before shipping → status CANCELLED
 */

// @Entity marks this as a JPA entity
@Entity

// @Table specifies table name, indexes, and constraints
@Table(name = "orders", indexes = {
        // Index on user_id for fast user order lookups
        // Query: "Show all orders for user #123"
        // Without index: Full table scan
        // With index: Direct lookup by user_id
        @Index(name = "idx_user_id", columnList = "user_id"),

        // Index on order_number for order tracking
        // Query: "Find order by order number ORD-20240115-001"
        // Used when customer tracks their order
        @Index(name = "idx_order_number", columnList = "order_number"),

        // Index on status for administrative queries
        // Query: "Show all PENDING orders"
        // Query: "Count SHIPPED orders today"
        // Frequently used for order management dashboards
        @Index(name = "idx_status", columnList = "status"),

        // Composite index on user_id and created_at
        // Query: "Show orders for user #123 ordered by date"
        // Optimizes pagination of user's order history
        @Index(name = "idx_user_created", columnList = "user_id, created_at")
})

// @Data (Lombok) generates getters, setters, toString, equals, hashCode
@Data

// @NoArgsConstructor (Lombok) generates no-argument constructor (required by JPA)
@NoArgsConstructor

// @AllArgsConstructor (Lombok) generates constructor with all fields
@AllArgsConstructor
public class Order {

    /**
     * Primary Key
     *
     * Unique identifier for this order.
     * Auto-generated by database using auto-increment.
     */
    @Id  // Marks as primary key
    @GeneratedValue(strategy = GenerationType.IDENTITY)  // Auto-increment
    private Long id;

    /**
     * User ID
     *
     * Reference to the user who placed this order.
     * Points to User entity in User Service database.
     *
     * Why not a foreign key?
     * ----------------------
     * - User exists in different database (User Service)
     * - Microservices use separate databases
     * - Cross-database foreign keys not supported
     * - Services are loosely coupled
     *
     * This is a logical reference:
     * - Order Service stores user ID
     * - When needed, calls User Service API to get user details
     * - Example: GET /user-service/api/users/{userId}
     *
     * nullable = false: Every order must have a user
     */
    @Column(name = "user_id", nullable = false)
    private Long userId;

    /**
     * Order Number
     *
     * Human-readable unique identifier for the order.
     * Used for customer communication and tracking.
     *
     * Format: ORD-YYYYMMDD-NNN
     * Examples:
     * - ORD-20240115-001 (First order on Jan 15, 2024)
     * - ORD-20240115-002 (Second order on Jan 15, 2024)
     * - ORD-20240116-001 (First order on Jan 16, 2024)
     *
     * Why separate order number from ID?
     * -----------------------------------
     * ID (1, 2, 3...):
     * - Database internal identifier
     * - Sequential but meaningless
     * - Exposes business metrics (e.g., "We've had 50,000 orders")
     * - Not user-friendly
     *
     * Order Number (ORD-20240115-001):
     * - User-friendly
     * - Includes date for easy reference
     * - Doesn't expose total order count
     * - Easier for customer service
     * - Can be used in URLs, emails, tracking
     *
     * Constraints:
     * - unique = true: No duplicate order numbers
     * - nullable = false: Every order must have an order number
     * - length = 50: Enough for any format
     */
    @Column(name = "order_number", nullable = false, unique = true, length = 50)
    private String orderNumber;

    /**
     * Order Status
     *
     * Current state of the order in its lifecycle.
     * See OrderStatus enum for detailed documentation.
     *
     * @Enumerated(EnumType.STRING):
     * - Stores enum name as string in database
     * - Database value: "PENDING", "CONFIRMED", etc.
     * - Better than EnumType.ORDINAL (stores position number)
     *
     * Why STRING vs ORDINAL?
     * ----------------------
     * ORDINAL (0, 1, 2...):
     * - Problem: If you add new status in middle, numbers change!
     * - Existing data becomes inconsistent
     * - Hard to debug
     *
     * STRING ("PENDING", "CONFIRMED"...):
     * - Human-readable in database
     * - Safe to add new statuses
     * - Safe to reorder statuses
     * - Easy to debug
     *
     * nullable = false: Every order must have a status
     * length = 20: Longest status name + buffer
     */
    @Enumerated(EnumType.STRING)  // Store enum name, not ordinal position
    @Column(name = "status", nullable = false, length = 20)
    private OrderStatus status;

    /**
     * Total Amount
     *
     * Total cost of the order including all items.
     * Calculated as sum of all order item subtotals.
     *
     * Why BigDecimal?
     * ---------------
     * For monetary calculations, BigDecimal is essential:
     * - Exact decimal precision (no rounding errors)
     * - float/double can cause: 0.1 + 0.2 = 0.30000000000000004
     * - BigDecimal ensures: 0.1 + 0.2 = 0.3 (exact!)
     *
     * Database Mapping:
     * - precision = 10: Total digits (e.g., 9999999.99 has 9 digits)
     * - scale = 2: Decimal places (cents)
     * - Supports values up to: $99,999,999.99
     * - Column type: DECIMAL(10,2)
     *
     * Calculation:
     * If order has 3 items:
     * - Item 1: 2 x $999.99 = $1999.98
     * - Item 2: 1 x $29.99 = $29.99
     * - Item 3: 3 x $15.00 = $45.00
     * Total Amount = $2074.97
     *
     * Note: In real system, might also include:
     * - Shipping costs
     * - Taxes
     * - Discounts/coupons
     * For simplicity, we just sum item subtotals
     */
    @Column(name = "total_amount", nullable = false, precision = 10, scale = 2)
    private BigDecimal totalAmount;

    /**
     * Shipping Address ID
     *
     * Reference to the delivery address for this order.
     * Points to Address entity in User Service database.
     *
     * Why store address ID vs full address?
     * --------------------------------------
     * Option 1: Store address ID (our approach)
     * - References user's saved address
     * - If user updates address, doesn't affect old orders
     * - Smaller storage
     *
     * Option 2: Store full address snapshot
     * - Copy all address fields to order
     * - Preserves exact shipping address
     * - Better historical accuracy
     * - More storage
     *
     * We choose Option 1 for simplicity.
     * Production systems often use Option 2 to preserve exact historical data.
     *
     * nullable = true: Address is optional (digital products, pickup orders)
     */
    @Column(name = "shipping_address_id", nullable = true)
    private Long shippingAddressId;

    /**
     * Payment Method
     *
     * How the customer paid for this order.
     *
     * Common values:
     * - "CREDIT_CARD"
     * - "DEBIT_CARD"
     * - "PAYPAL"
     * - "BANK_TRANSFER"
     * - "CASH_ON_DELIVERY"
     * - "CRYPTO"
     *
     * Note: In production, this might be an enum or reference to Payment entity
     * For simplicity, we use a string.
     *
     * This stores the TYPE of payment, not payment details.
     * Actual payment details (card number, transaction ID) stored in Payment Service.
     */
    @Column(name = "payment_method", nullable = true, length = 50)
    private String paymentMethod;

    /**
     * Order Items
     *
     * List of products in this order.
     * One-to-Many relationship: One order has many order items.
     *
     * @OneToMany:
     * - One order can have multiple order items
     * - Defines parent-child relationship
     *
     * mappedBy = "order":
     * - "order" refers to the field name in OrderItem entity
     * - OrderItem has: private Order order;
     * - This tells JPA which field in OrderItem links back to Order
     * - Order is the owning side, OrderItem is the inverse side
     *
     * cascade = CascadeType.ALL:
     * - Operations on Order cascade to OrderItems
     * - save(order) → automatically saves order items
     * - delete(order) → automatically deletes order items
     * - Ensures data consistency
     *
     * CascadeType options:
     * - ALL: Cascade all operations (persist, merge, remove, refresh, detach)
     * - PERSIST: Cascade only save operations
     * - MERGE: Cascade only update operations
     * - REMOVE: Cascade only delete operations
     *
     * orphanRemoval = true:
     * - If an OrderItem is removed from the list, delete it from database
     * - Example: order.getItems().remove(item) → item deleted from DB
     * - Keeps database clean (no orphaned order items)
     *
     * fetch = FetchType.LAZY:
     * - Don't load order items when loading order
     * - Load items only when explicitly accessed
     * - Improves performance (fewer database queries)
     * - Example: order.getItems().size() triggers loading
     *
     * new ArrayList<>():
     * - Initialize to empty list (not null)
     * - Prevents NullPointerException
     * - Can safely add items: order.getItems().add(newItem)
     */
    @OneToMany(
            mappedBy = "order",           // Field in OrderItem that references Order
            cascade = CascadeType.ALL,     // Cascade all operations
            orphanRemoval = true,          // Delete orphaned items
            fetch = FetchType.LAZY         // Load items on demand
    )
    private List<OrderItem> items = new ArrayList<>();

    /**
     * Created Timestamp
     *
     * When this order was created (placed by customer).
     * Set automatically when order is first saved.
     *
     * Used for:
     * - Order history sorting
     * - Analytics (orders per day, month, etc.)
     * - Reporting
     * - Customer service (when was order placed?)
     *
     * @Column settings:
     * - nullable = false: Must have creation time
     * - updatable = false: Cannot be changed after creation
     *   (order creation time is fixed)
     */
    @Column(name = "created_at", nullable = false, updatable = false)
    private LocalDateTime createdAt;

    /**
     * Updated Timestamp
     *
     * When this order was last modified.
     * Updated automatically on every save.
     *
     * Used for:
     * - Tracking order status changes
     * - Audit trail
     * - Debugging (when was order last updated?)
     *
     * @Column settings:
     * - nullable = false: Must have update time
     * - updatable = true: Can be changed (default, not specified)
     */
    @Column(name = "updated_at", nullable = false)
    private LocalDateTime updatedAt;

    /**
     * Pre-Persist Callback
     *
     * Executed automatically BEFORE entity is first saved to database.
     * Sets timestamps and initializes default values.
     *
     * When called:
     * 1. new Order() created
     * 2. Properties set
     * 3. repository.save(order) called
     * 4. @PrePersist triggers onCreate()
     * 5. Timestamps set
     * 6. INSERT SQL executed
     */
    @PrePersist
    protected void onCreate() {
        // Get current date and time
        LocalDateTime now = LocalDateTime.now();

        // Set creation timestamp
        createdAt = now;

        // Set update timestamp
        updatedAt = now;

        // Set default status if not already set
        // New orders start as PENDING (awaiting payment/confirmation)
        if (status == null) {
            status = OrderStatus.PENDING;
        }
    }

    /**
     * Pre-Update Callback
     *
     * Executed automatically BEFORE entity is updated in database.
     * Updates the updatedAt timestamp.
     *
     * When called:
     * 1. Existing order loaded
     * 2. Properties modified
     * 3. repository.save(order) called
     * 4. @PreUpdate triggers onUpdate()
     * 5. updatedAt timestamp updated
     * 6. UPDATE SQL executed
     */
    @PreUpdate
    protected void onUpdate() {
        // Update the timestamp
        updatedAt = LocalDateTime.now();
    }

    // =========================================================================
    // Helper Methods (Optional - can be in Service layer instead)
    // =========================================================================
    //
    // /**
    //  * Add an order item to this order
    //  */
    // public void addItem(OrderItem item) {
    //     items.add(item);
    //     item.setOrder(this);  // Set bidirectional relationship
    // }
    //
    // /**
    //  * Remove an order item from this order
    //  */
    // public void removeItem(OrderItem item) {
    //     items.remove(item);
    //     item.setOrder(null);  // Clear bidirectional relationship
    // }
    //
    // /**
    //  * Calculate total amount from order items
    //  */
    // public void calculateTotalAmount() {
    //     this.totalAmount = items.stream()
    //         .map(OrderItem::getSubtotal)
    //         .reduce(BigDecimal.ZERO, BigDecimal::add);
    // }
    //
    // /**
    //  * Check if order can be cancelled
    //  */
    // public boolean canBeCancelled() {
    //     return status == OrderStatus.PENDING ||
    //            status == OrderStatus.CONFIRMED;
    // }
    //
    // /**
    //  * Check if order is in final state
    //  */
    // public boolean isFinalState() {
    //     return status == OrderStatus.DELIVERED ||
    //            status == OrderStatus.CANCELLED;
    // }
    //
    // =========================================================================
    // Example Usage
    // =========================================================================
    //
    // // Create order
    // Order order = new Order();
    // order.setUserId(123L);
    // order.setOrderNumber("ORD-20240115-001");
    // order.setShippingAddressId(456L);
    // order.setPaymentMethod("CREDIT_CARD");
    //
    // // Add order items
    // OrderItem item1 = new OrderItem();
    // item1.setProductId(789L);
    // item1.setProductName("Laptop");
    // item1.setProductPrice(new BigDecimal("999.99"));
    // item1.setQuantity(1);
    // item1.setSubtotal(new BigDecimal("999.99"));
    // order.getItems().add(item1);
    // item1.setOrder(order);
    //
    // // Calculate total
    // order.setTotalAmount(new BigDecimal("999.99"));
    //
    // // Save (onCreate() called automatically)
    // orderRepository.save(order);
    // // Both order and item1 are saved (cascade = ALL)
    //
    // =========================================================================
    // Database Schema
    // =========================================================================
    //
    // CREATE TABLE orders (
    //     id BIGINT AUTO_INCREMENT PRIMARY KEY,
    //     user_id BIGINT NOT NULL,
    //     order_number VARCHAR(50) NOT NULL UNIQUE,
    //     status VARCHAR(20) NOT NULL,
    //     total_amount DECIMAL(10,2) NOT NULL,
    //     shipping_address_id BIGINT,
    //     payment_method VARCHAR(50),
    //     created_at DATETIME NOT NULL,
    //     updated_at DATETIME NOT NULL,
    //     INDEX idx_user_id (user_id),
    //     INDEX idx_order_number (order_number),
    //     INDEX idx_status (status),
    //     INDEX idx_user_created (user_id, created_at)
    // );
}
