package com.ecommerce.orderservice.dto;

// Import validation annotations
import jakarta.validation.Valid;
import jakarta.validation.constraints.NotEmpty;
import jakarta.validation.constraints.NotNull;

// Import Lombok annotations
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

// Import List
import java.util.List;

/**
 * Order Request DTO
 *
 * Used when a customer creates a new order.
 * Contains the list of items to order and shipping details.
 *
 * Workflow:
 * 1. Customer adds products to cart
 * 2. Customer proceeds to checkout
 * 3. Frontend sends OrderRequest to API
 * 4. Service validates and creates order
 *
 * Example JSON request:
 * {
 *   "items": [
 *     {
 *       "productId": 123,
 *       "quantity": 2
 *     },
 *     {
 *       "productId": 456,
 *       "quantity": 1
 *     }
 *   ],
 *   "shippingAddressId": 789,
 *   "paymentMethod": "CREDIT_CARD"
 * }
 *
 * What the service does with this data:
 * 1. Extract user ID from JWT token (authentication)
 * 2. Validate all product IDs exist in Product Service
 * 3. Fetch current prices from Product Service
 * 4. Calculate subtotals and total amount
 * 5. Generate unique order number
 * 6. Validate shipping address belongs to user
 * 7. Create Order entity with status PENDING
 * 8. Create OrderItem entities for each item
 * 9. Save to database
 * 10. Return OrderResponse
 */
@Data               // Lombok: getters, setters, toString, equals, hashCode
@NoArgsConstructor  // Lombok: no-arg constructor for Jackson
@AllArgsConstructor // Lombok: all-args constructor for testing
public class OrderRequest {

    /**
     * Order Items
     *
     * List of products and quantities to order.
     * Each item specifies a product ID and how many units to order.
     *
     * Validations:
     * - @NotEmpty: Must have at least one item
     *   (Cannot create empty order)
     * - @Valid: Each OrderItemRequest must pass its own validations
     *   (Product ID not null, quantity >= 1)
     *
     * Example:
     * [
     *   {"productId": 123, "quantity": 2},
     *   {"productId": 456, "quantity": 1}
     * ]
     *
     * Business validations (in service layer):
     * - All product IDs must exist in Product Service
     * - Products must be active/available
     * - Sufficient inventory for requested quantities
     */
    @NotEmpty(message = "Order must contain at least one item")
    @Valid  // Triggers validation on each OrderItemRequest in the list
    private List<OrderItemRequest> items;

    /**
     * Shipping Address ID
     *
     * Reference to the user's shipping address for delivery.
     * Points to Address entity in User Service.
     *
     * Validations:
     * - @NotNull: Shipping address is required
     *   (Cannot ship without an address)
     *
     * Business validations (in service layer):
     * - Address must exist in User Service
     * - Address must belong to the authenticated user
     *   (Cannot ship to someone else's address)
     * - Address must be a shipping address type
     *
     * Example: 789
     *
     * Note: For digital products or pickup orders,
     * this requirement could be made optional in the future.
     */
    @NotNull(message = "Shipping address ID is required")
    private Long shippingAddressId;

    /**
     * Payment Method
     *
     * How the customer will pay for this order.
     *
     * Common values:
     * - "CREDIT_CARD"
     * - "DEBIT_CARD"
     * - "PAYPAL"
     * - "BANK_TRANSFER"
     * - "CASH_ON_DELIVERY"
     *
     * Validations:
     * - Currently no validation (can be any string)
     * - In production, could use enum or validate against allowed methods
     *
     * Note: This just records the payment type.
     * Actual payment processing happens in Payment Service.
     *
     * Example: "CREDIT_CARD"
     *
     * Future enhancement:
     * Could add payment details (card token, transaction ID)
     * but those should be handled by Payment Service for PCI compliance.
     */
    private String paymentMethod;

    // =========================================================================
    // Notes on what's NOT in this DTO
    // =========================================================================
    //
    // User ID:
    // - Not needed in request
    // - Extracted from JWT token automatically
    // - More secure (user can't order for someone else)
    //
    // Order Number:
    // - Generated by service
    // - Not provided by client
    // - Ensures uniqueness
    //
    // Total Amount:
    // - Calculated by service
    // - Not trusted from client
    // - Prevents price manipulation
    //
    // Product Prices:
    // - Fetched from Product Service
    // - Not provided by client
    // - Ensures current prices are used
    // - Prevents price manipulation
    //
    // Order Status:
    // - Defaults to PENDING
    // - Not specified in request
    // - Controlled by order lifecycle
    //
    // Timestamps:
    // - Set automatically by entity
    // - Not provided by client
    //
    // =========================================================================
    // Security Considerations
    // =========================================================================
    //
    // 1. User Authentication:
    //    - User ID from JWT token, not request body
    //    - Prevents ordering for other users
    //
    // 2. Price Validation:
    //    - Prices fetched from Product Service
    //    - Client cannot manipulate prices
    //
    // 3. Address Ownership:
    //    - Service validates address belongs to user
    //    - Prevents shipping to unauthorized addresses
    //
    // 4. Inventory Validation:
    //    - Service checks product availability
    //    - Prevents ordering out-of-stock items
    //
    // =========================================================================
    // Example Usage in Controller
    // =========================================================================
    //
    // @PostMapping
    // public ResponseEntity<OrderResponse> createOrder(
    //     @Valid @RequestBody OrderRequest request,
    //     Authentication authentication
    // ) {
    //     String email = authentication.getName();
    //     OrderResponse order = orderService.createOrder(email, request);
    //     return ResponseEntity.status(HttpStatus.CREATED).body(order);
    // }
}
