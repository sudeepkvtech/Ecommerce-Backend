package com.ecommerce.paymentservice.dto;

// Import validation annotations
import jakarta.validation.constraints.DecimalMin;
import jakarta.validation.constraints.NotNull;

// Import Lombok annotations
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

// Import payment method enum
import com.ecommerce.paymentservice.entity.PaymentMethod;

// Import BigDecimal for monetary values
import java.math.BigDecimal;

/**
 * Process Payment Request DTO
 *
 * Used when initiating a payment transaction.
 * Contains all information needed to process a payment.
 *
 * Who sends this?
 * ===============
 * - Order Service: After order is created, sends payment request
 * - Frontend: In some architectures, frontend may send directly
 *
 * Workflow:
 * =========
 * 1. Customer places order in Order Service
 * 2. Order Service creates order with PENDING status
 * 3. Order Service sends ProcessPaymentRequest to Payment Service
 * 4. Payment Service processes payment via payment gateway
 * 5. Payment Service returns PaymentResponse
 * 6. Order Service updates order status based on payment result
 *
 * Example JSON request:
 * =====================
 * {
 *   "orderId": 123,
 *   "userId": 456,
 *   "amount": 99.99,
 *   "paymentMethod": "CREDIT_CARD",
 *   "paymentToken": "tok_1234567890abcdef"
 * }
 *
 * Security Considerations:
 * ========================
 * 1. Amount Validation:
 *    - Payment Service should verify amount matches order total
 *    - Prevents price manipulation
 *    - Call Order Service to get actual order amount
 *    - Compare with request amount
 *
 * 2. Payment Token:
 *    - Never send raw credit card numbers
 *    - Use tokenization (Stripe tokens, PayPal tokens)
 *    - Token generated by payment gateway's client-side library
 *    - Token used once, then discarded
 *
 * 3. User Authorization:
 *    - Verify userId matches authenticated user
 *    - Prevent paying for someone else's order
 *    - Extract user from JWT token
 *
 * Payment Flow with Tokenization:
 * ================================
 * 1. Customer enters card on frontend
 * 2. Frontend sends card to Stripe directly (HTTPS)
 * 3. Stripe returns token: tok_1234567890abcdef
 * 4. Frontend sends token to backend (not card number)
 * 5. Backend sends token to Payment Service in this DTO
 * 6. Payment Service charges token via Stripe API
 * 7. Stripe processes with actual card
 * 8. Response returned
 *
 * This way:
 * - Card number never touches your server
 * - PCI compliance easier
 * - More secure
 */
@Data               // Lombok: getters, setters, toString, equals, hashCode
@NoArgsConstructor  // Lombok: no-arg constructor for Jackson deserialization
@AllArgsConstructor // Lombok: all-args constructor for testing
public class ProcessPaymentRequest {

    /**
     * Order ID
     *
     * Reference to the order being paid for.
     * Must exist in Order Service.
     *
     * Validations:
     * - @NotNull: Required field
     *
     * Business validations (in service layer):
     * - Order must exist
     * - Order must belong to the user
     * - Order must not already have a successful payment
     * - Order status must be PENDING (not cancelled)
     *
     * Example: 123 (refers to order #123)
     *
     * Why required?
     * - Links payment to specific order
     * - Prevents duplicate payments
     * - Enables refund processing later
     * - Required for reconciliation
     */
    @NotNull(message = "Order ID is required")
    private Long orderId;

    /**
     * User ID
     *
     * Reference to the user making the payment.
     * Must match authenticated user.
     *
     * Validations:
     * - @NotNull: Required field
     *
     * Business validations (in service layer):
     * - User must exist in User Service
     * - User must own the order (orderId)
     * - Prevent paying for someone else's order
     *
     * Security note:
     * - In production, extract userId from JWT token
     * - Don't trust userId from request body
     * - Verify request.userId == jwtToken.userId
     *
     * Example: 456 (refers to user #456)
     *
     * Alternative approach:
     * - Don't include userId in request
     * - Extract from JWT token in controller:
     *   String email = authentication.getName();
     *   Long userId = userService.getUserIdByEmail(email);
     * - More secure (can't be manipulated)
     */
    @NotNull(message = "User ID is required")
    private Long userId;

    /**
     * Amount
     *
     * Total payment amount.
     *
     * Validations:
     * - @NotNull: Required field
     * - @DecimalMin: Must be greater than 0.01 (at least 1 cent)
     *
     * Why BigDecimal?
     * - Exact precision for money
     * - No floating-point errors
     * - Required for financial calculations
     *
     * Business validations (in service layer):
     * - Amount must match order total
     * - Prevents price manipulation
     * - Service calls Order Service to verify:
     *   Order order = orderService.getOrder(orderId);
     *   if (!request.getAmount().equals(order.getTotalAmount())) {
     *       throw new BadRequestException("Amount mismatch");
     *   }
     *
     * Currency:
     * - Currently assumes single currency (e.g., USD)
     * - For multi-currency, add currencyCode field
     *
     * Example: 99.99 (represents $99.99)
     *
     * Payment gateway considerations:
     * - Stripe: Amount in cents (9999 for $99.99)
     * - PayPal: Amount as decimal (99.99)
     * - Convert in service based on payment method
     */
    @NotNull(message = "Amount is required")
    @DecimalMin(value = "0.01", message = "Amount must be greater than 0")
    private BigDecimal amount;

    /**
     * Payment Method
     *
     * How the customer wants to pay.
     *
     * Validations:
     * - @NotNull: Required field
     * - Enum validation: Must be valid PaymentMethod value
     *
     * Supported methods:
     * - CREDIT_CARD: Visa, Mastercard, Amex, etc.
     * - DEBIT_CARD: Direct debit
     * - PAYPAL: PayPal account
     * - BANK_TRANSFER: Wire transfer / ACH
     * - CASH_ON_DELIVERY: Pay in cash at delivery
     *
     * Processing varies by method:
     * - Card payments: Use payment token, instant processing
     * - PayPal: Redirect flow or token-based
     * - Bank transfer: Manual verification, delayed
     * - COD: No immediate processing, marked as pending
     *
     * Example: PaymentMethod.CREDIT_CARD
     *
     * JSON:
     * "paymentMethod": "CREDIT_CARD"
     */
    @NotNull(message = "Payment method is required")
    private PaymentMethod paymentMethod;

    /**
     * Payment Token
     *
     * Tokenized payment information from payment gateway.
     * Format depends on payment method.
     *
     * What is a payment token?
     * - Temporary, single-use identifier for payment details
     * - Generated by payment gateway's client-side library
     * - Replaces sensitive payment information
     * - Cannot be used to retrieve actual payment details
     * - Expires after use or short time period
     *
     * Token formats by method:
     * ------------------------
     * Credit/Debit Card (Stripe):
     * - Format: tok_1234567890abcdefghijklmn
     * - Generated by Stripe.js on frontend
     * - Represents card number, expiry, CVV
     * - Single use only
     *
     * PayPal:
     * - Format: PAY-1234567890ABCDEFGHIJKLMN
     * - or EC-1234567890ABCDEFGHIJKLMN (Express Checkout)
     * - Generated after PayPal authorization
     * - Represents PayPal account authorization
     *
     * Bank Transfer:
     * - May be null (manual transfer)
     * - Or reference number from ACH/SEPA
     *
     * Cash on Delivery:
     * - Usually null (no online transaction)
     * - Payment happens at delivery
     *
     * Validations:
     * - Not annotated as @NotNull because some methods don't need it
     * - Business validation in service:
     *   if (paymentMethod.requiresToken() && token == null) {
     *       throw new BadRequestException("Payment token required");
     *   }
     *
     * Security:
     * - Token can only be used once
     * - Token expires quickly (usually 10-30 minutes)
     * - Token doesn't contain actual payment details
     * - Payment gateway validates token
     * - Invalid token = payment rejected
     *
     * Example workflow with Stripe:
     * -----------------------------
     * // Frontend (JavaScript)
     * const card = elements.create('card');
     * const {token, error} = await stripe.createToken(card);
     * // token.id = "tok_1234567890abcdef"
     *
     * // Send to backend
     * fetch('/api/payments', {
     *     method: 'POST',
     *     body: JSON.stringify({
     *         orderId: 123,
     *         userId: 456,
     *         amount: 99.99,
     *         paymentMethod: 'CREDIT_CARD',
     *         paymentToken: token.id  // <-- This field
     *     })
     * });
     *
     * // Backend (Java)
     * public PaymentResponse processPayment(ProcessPaymentRequest request) {
     *     // Use token to charge card
     *     Map<String, Object> params = new HashMap<>();
     *     params.put("amount", request.getAmount().multiply(new BigDecimal("100")).longValue());
     *     params.put("currency", "usd");
     *     params.put("source", request.getPaymentToken());  // <-- Token used here
     *
     *     Charge charge = Charge.create(params);
     *     // ...
     * }
     *
     * Why not send card number directly?
     * -----------------------------------
     * Bad (insecure):
     * {
     *     "cardNumber": "4242424242424242",
     *     "expiryMonth": "12",
     *     "expiryYear": "2025",
     *     "cvv": "123"
     * }
     *
     * Problems:
     * - Sensitive data on your server
     * - PCI DSS compliance required
     * - Risk of data breach
     * - Legal liability
     * - Expensive security audits
     *
     * Good (secure with token):
     * {
     *     "paymentToken": "tok_1234567890abcdef"
     * }
     *
     * Benefits:
     * - No sensitive data on your server
     * - Easier PCI compliance (SAQ A level)
     * - Payment gateway handles security
     * - Lower liability
     * - Lower security costs
     *
     * Example: "tok_1234567890abcdef" (Stripe card token)
     */
    private String paymentToken;

    /**
     * Additional Notes
     * ================
     *
     * Future enhancements:
     * --------------------
     * 1. Currency code:
     *    private String currencyCode;  // "USD", "EUR", "GBP"
     *
     * 2. Save payment method:
     *    private Boolean savePaymentMethod;  // For future one-click payments
     *
     * 3. Billing address:
     *    private AddressDTO billingAddress;  // For AVS verification
     *
     * 4. Metadata:
     *    private Map<String, String> metadata;  // Custom data for gateway
     *
     * 5. Idempotency key:
     *    private String idempotencyKey;  // Prevent duplicate charges
     *
     * Example with idempotency:
     * -------------------------
     * ProcessPaymentRequest request = new ProcessPaymentRequest();
     * request.setOrderId(123L);
     * request.setUserId(456L);
     * request.setAmount(new BigDecimal("99.99"));
     * request.setPaymentMethod(PaymentMethod.CREDIT_CARD);
     * request.setPaymentToken("tok_1234567890abcdef");
     * request.setIdempotencyKey("order-123-" + UUID.randomUUID());
     *
     * // If request is retried (network timeout), idempotency key
     * // ensures the same payment isn't charged twice
     */
}
