// Package declaration - this class belongs to the dto package
package com.ecommerce.productservice.dto;

// Import Lombok annotations
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

// Import Java time class for timestamps
import java.time.LocalDateTime;

/**
 * Category Response DTO (Data Transfer Object)
 *
 * What is a Response DTO?
 * -----------------------
 * A Response DTO is used to send data FROM the server TO the client.
 * It defines what information the client will receive in API responses.
 *
 * CategoryRequest vs CategoryResponse:
 * ------------------------------------
 * CategoryRequest (incoming):
 * - Used for POST, PUT requests
 * - Contains only fields client can provide (name, description, imageUrl)
 * - Has validation annotations
 * - Does NOT include: id, createdAt, updatedAt
 *
 * CategoryResponse (outgoing):
 * - Used for GET responses
 * - Contains all fields client should see
 * - No validation annotations (data is already validated)
 * - INCLUDES: id, createdAt, updatedAt
 *
 * Why separate Request and Response DTOs?
 * ----------------------------------------
 * 1. SECURITY: Don't accept ID in requests (prevents ID manipulation)
 *    - Client shouldn't set the ID, database generates it
 *    - Prevents users from modifying other categories by changing ID
 *
 * 2. CLARITY: Clear separation of what goes IN vs what comes OUT
 *    - Request: What client provides
 *    - Response: What client receives
 *
 * 3. VERSIONING: Can evolve independently
 *    - Add fields to response without affecting requests
 *    - Maintain backward compatibility
 *
 * Typical API Flow:
 * -----------------
 * 1. Client sends POST /api/categories with CategoryRequest:
 *    {
 *      "name": "Electronics",
 *      "description": "Electronic devices"
 *    }
 *
 * 2. Server creates category and returns CategoryResponse:
 *    {
 *      "id": 1,
 *      "name": "Electronics",
 *      "description": "Electronic devices",
 *      "imageUrl": null,
 *      "productCount": 0,
 *      "createdAt": "2024-01-15T10:30:00",
 *      "updatedAt": "2024-01-15T10:30:00"
 *    }
 */

// @Data is a Lombok annotation that generates:
// - Getters for all fields
// - Setters for all fields
// - toString() method (useful for logging)
// - equals() and hashCode() methods
@Data

// @NoArgsConstructor generates a no-argument constructor
// Required by:
// - Jackson (JSON serialization library)
// - JPA/Hibernate for entity conversion
@NoArgsConstructor

// @AllArgsConstructor generates a constructor with all fields as parameters
// Useful for creating response objects in one line
// Example: new CategoryResponse(1L, "Electronics", "Description", ...)
@AllArgsConstructor

// @Builder provides the Builder pattern for object creation
// Benefits:
// 1. Readable code: CategoryResponse.builder().id(1L).name("Electronics").build()
// 2. Flexible: Can set only the fields you need
// 3. Immutable-friendly: Can create objects without setters
//
// Example usage:
// CategoryResponse response = CategoryResponse.builder()
//     .id(category.getId())
//     .name(category.getName())
//     .description(category.getDescription())
//     .build();
@Builder
public class CategoryResponse {

    /**
     * Category ID
     *
     * The unique identifier generated by the database
     *
     * Why include ID in response but not in request?
     * -----------------------------------------------
     * - Server controls ID generation (security)
     * - Client needs ID to:
     *   1. Update the category (PUT /api/categories/{id})
     *   2. Delete the category (DELETE /api/categories/{id})
     *   3. Filter products by category (GET /api/products?categoryId={id})
     *   4. Display category details
     *
     * The ID is the "handle" that allows client to reference this category
     */
    private Long id;

    /**
     * Category Name
     *
     * The name of the category (e.g., "Electronics", "Clothing")
     *
     * This field is always included in the response because:
     * - It's the primary identifier users see
     * - Required for displaying category in UI
     * - Used for navigation and breadcrumbs
     */
    private String name;

    /**
     * Category Description
     *
     * Detailed description of what products belong to this category
     *
     * This field may be null if:
     * - No description was provided when creating the category
     * - Description was explicitly removed during update
     *
     * Frontend should handle null gracefully:
     * - Don't display description section if null
     * - Or show placeholder text like "No description available"
     */
    private String description;

    /**
     * Category Image URL
     *
     * URL or path to the category image
     *
     * This field may be null if:
     * - No image was provided
     * - Image was removed
     *
     * Frontend handling:
     * - Display placeholder image if null
     * - Or hide image section entirely
     *
     * Example values:
     * - "https://cdn.example.com/categories/electronics.jpg"
     * - "/images/categories/electronics.jpg"
     * - null
     */
    private String imageUrl;

    /**
     * Product Count
     *
     * Number of products in this category
     *
     * This is a computed field - not stored in database
     * Calculated by counting products with this category_id
     *
     * Use cases:
     * ----------
     * 1. Display in category list: "Electronics (125 products)"
     * 2. Show empty categories: "No products in this category"
     * 3. Prevent deletion: "Cannot delete category with products"
     * 4. Analytics: "Most popular categories"
     *
     * How it's calculated:
     * --------------------
     * In Service layer:
     * int count = category.getProducts().size();
     * // Or query database:
     * int count = productRepository.countByCategoryId(categoryId);
     *
     * Performance consideration:
     * --------------------------
     * - Loading all products just to count them is inefficient
     * - Better to use COUNT query: SELECT COUNT(*) FROM products WHERE category_id = ?
     * - Or cache the count in database (updated when products added/removed)
     */
    private Integer productCount;

    /**
     * Created Timestamp
     *
     * When this category was first created
     *
     * Use cases:
     * ----------
     * 1. Display "Created on: January 15, 2024"
     * 2. Sort by "Recently added"
     * 3. Audit trail: "Who created this and when?"
     * 4. Analytics: "Categories created per month"
     *
     * This value NEVER changes after creation
     * Even if category is updated, createdAt remains the same
     *
     * Format in JSON:
     * ---------------
     * By default, LocalDateTime serializes to:
     * "2024-01-15T10:30:00"
     *
     * Can be customized with @JsonFormat:
     * @JsonFormat(pattern = "yyyy-MM-dd HH:mm:ss")
     * Would produce: "2024-01-15 10:30:00"
     */
    private LocalDateTime createdAt;

    /**
     * Updated Timestamp
     *
     * When this category was last modified
     *
     * Use cases:
     * ----------
     * 1. Display "Last updated: January 20, 2024"
     * 2. Sort by "Recently modified"
     * 3. Track changes: "When was this category last edited?"
     * 4. Caching: Invalidate cache when updatedAt changes
     *
     * This value changes every time the category is updated
     *
     * Tracking changes:
     * -----------------
     * If createdAt = updatedAt: Category was never modified
     * If createdAt < updatedAt: Category was modified after creation
     *
     * Example timeline:
     * - Created: 2024-01-15 10:00:00 (createdAt = updatedAt)
     * - First update: 2024-01-16 14:30:00 (updatedAt changes)
     * - Second update: 2024-01-20 09:15:00 (updatedAt changes again)
     * - createdAt always remains 2024-01-15 10:00:00
     */
    private LocalDateTime updatedAt;

    // =========================================================================
    // Entity to DTO Conversion
    // =========================================================================
    //
    // In the Service layer, we convert Category entity to CategoryResponse:
    //
    // Method 1: Manual mapping
    // ------------------------
    // public CategoryResponse toResponse(Category category) {
    //     CategoryResponse response = new CategoryResponse();
    //     response.setId(category.getId());
    //     response.setName(category.getName());
    //     response.setDescription(category.getDescription());
    //     response.setImageUrl(category.getImageUrl());
    //     response.setProductCount(category.getProducts().size());
    //     response.setCreatedAt(category.getCreatedAt());
    //     response.setUpdatedAt(category.getUpdatedAt());
    //     return response;
    // }
    //
    // Method 2: Builder pattern (cleaner)
    // ------------------------------------
    // public CategoryResponse toResponse(Category category) {
    //     return CategoryResponse.builder()
    //         .id(category.getId())
    //         .name(category.getName())
    //         .description(category.getDescription())
    //         .imageUrl(category.getImageUrl())
    //         .productCount(category.getProducts().size())
    //         .createdAt(category.getCreatedAt())
    //         .updatedAt(category.getUpdatedAt())
    //         .build();
    // }
    //
    // Method 3: ModelMapper or MapStruct (automatic)
    // -----------------------------------------------
    // ModelMapper automatically maps fields with same names:
    // CategoryResponse response = modelMapper.map(category, CategoryResponse.class);
    // // Still need to set productCount manually:
    // response.setProductCount(category.getProducts().size());
    //
    // =========================================================================
    // JSON Serialization
    // =========================================================================
    //
    // When this object is returned from a REST controller:
    //
    // @GetMapping("/{id}")
    // public ResponseEntity<CategoryResponse> getCategory(@PathVariable Long id) {
    //     CategoryResponse response = categoryService.getCategoryById(id);
    //     return ResponseEntity.ok(response);
    // }
    //
    // Spring automatically converts CategoryResponse to JSON:
    // {
    //   "id": 1,
    //   "name": "Electronics",
    //   "description": "Electronic devices and accessories",
    //   "imageUrl": "https://cdn.example.com/categories/electronics.jpg",
    //   "productCount": 125,
    //   "createdAt": "2024-01-15T10:30:00",
    //   "updatedAt": "2024-01-20T14:45:00"
    // }
    //
    // This JSON is sent to the client as the HTTP response body
}
