package com.ecommerce.inventoryservice.entity;

// Import JPA annotations
import jakarta.persistence.*;

// Import Lombok annotations
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

// Import time classes
import java.time.LocalDateTime;

/**
 * Inventory Entity
 *
 * Represents current stock level for a product.
 * One inventory record per product.
 *
 * What is Inventory?
 * ==================
 * Inventory tracks how many units of each product are:
 * - Available: Can be sold to customers
 * - Reserved: Held for pending orders
 * - Total: Available + Reserved
 *
 * Relationship with Other Services
 * =================================
 * - Product Service:
 *   - One Product → One Inventory record
 *   - When product created, inventory initialized
 *   - Product ID links the two
 *
 * - Order Service:
 *   - Order placement reserves stock
 *   - Order cancellation releases stock
 *   - Order completion commits stock (reduces available)
 *
 * - Payment Service:
 *   - Payment success → commit reservation
 *   - Payment failure → release reservation
 *
 * Database Table: inventory
 * ==========================
 * Columns:
 * - id: BIGINT PRIMARY KEY AUTO_INCREMENT
 * - product_id: BIGINT NOT NULL UNIQUE
 * - available_quantity: INT NOT NULL (can be sold)
 * - reserved_quantity: INT NOT NULL (held for orders)
 * - total_quantity: INT NOT NULL (available + reserved)
 * - low_stock_threshold: INT (when to alert)
 * - created_at: DATETIME NOT NULL
 * - updated_at: DATETIME NOT NULL
 *
 * Indexes:
 * - idx_product_id: Fast lookup by product
 * - idx_low_stock: Find products needing restock
 *
 * Key Concepts
 * ============
 *
 * Available Quantity:
 * - Stock that can be sold immediately
 * - Shown on product page: "X in stock"
 * - Used for "Add to Cart" validation
 *
 * Reserved Quantity:
 * - Stock held for pending orders
 * - Payment being processed
 * - Not available for other customers
 * - Released if payment fails
 *
 * Total Quantity:
 * - Physical stock in warehouse
 * - Always: total = available + reserved
 * - Used for reordering decisions
 *
 * Example Scenario:
 * =================
 * Product: Blue T-Shirt
 * Total: 100 units in warehouse
 * Available: 85 units (can be sold)
 * Reserved: 15 units (in pending orders)
 *
 * Customer A orders 2 units:
 * - Available: 85 → 83
 * - Reserved: 15 → 17
 * - Total: 100 (unchanged)
 *
 * Customer A payment succeeds:
 * - Available: 83 (unchanged)
 * - Reserved: 17 → 15
 * - Total: 100 → 98 (stock leaves warehouse)
 *
 * Customer B orders 5 units, payment fails:
 * - During order: Available 83→78, Reserved 15→20
 * - After failure: Available 78→83, Reserved 20→15
 * - Total: 98 (unchanged)
 */

// @Entity marks this as a JPA entity (database table)
@Entity

// @Table specifies table name and indexes
@Table(
    name = "inventory",
    indexes = {
        // Index on product_id for fast product lookup
        @Index(name = "idx_product_id", columnList = "product_id"),

        // Composite index to find low stock products
        @Index(name = "idx_low_stock", columnList = "available_quantity, low_stock_threshold")
    },
    // Unique constraint: one inventory record per product
    uniqueConstraints = {
        @UniqueConstraint(name = "uk_product_id", columnNames = {"product_id"})
    }
)

// Lombok annotations
@Data                // Getters, setters, toString, equals, hashCode
@NoArgsConstructor   // No-argument constructor (required by JPA)
@AllArgsConstructor  // Constructor with all fields
@Builder             // Builder pattern
public class Inventory {

    /**
     * Inventory ID
     *
     * Primary key, auto-generated by database.
     * Unique identifier for inventory record.
     *
     * Database column: id BIGINT PRIMARY KEY AUTO_INCREMENT
     */
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    /**
     * Product ID
     *
     * Reference to product in Product Service.
     * Links inventory to specific product.
     *
     * Why not @ManyToOne?
     * - Microservices don't share databases
     * - Product exists in Product Service database
     * - Inventory exists in Inventory Service database
     * - Reference by ID only, not database foreign key
     *
     * Unique constraint ensures one inventory per product.
     *
     * Database column: product_id BIGINT NOT NULL UNIQUE
     *
     * Example: 123 (refers to product #123 in Product Service)
     *
     * Usage:
     * // Get inventory for product
     * Inventory inv = inventoryRepository.findByProductId(123L);
     */
    @Column(name = "product_id", nullable = false, unique = true)
    private Long productId;

    /**
     * Available Quantity
     *
     * Number of units available to sell right now.
     * This is what customers see as "in stock".
     *
     * Calculation:
     * available = total - reserved
     *
     * Changes:
     * - Decreases when stock reserved for order
     * - Increases when reservation released
     * - Increases when new stock received (PURCHASE)
     * - Decreases when stock committed (SALE)
     *
     * Validation:
     * - Cannot be negative (unless allow-negative-stock enabled)
     * - Should always: available >= 0
     *
     * Database column: available_quantity INT NOT NULL
     *
     * Example: 85 (85 units can be sold right now)
     *
     * Display to customer:
     * - "85 in stock"
     * - "Only 5 left - order soon!"
     * - "Out of stock" (if 0)
     */
    @Column(name = "available_quantity", nullable = false)
    private Integer availableQuantity;

    /**
     * Reserved Quantity
     *
     * Number of units reserved for pending orders.
     * Not available for sale until reservation released.
     *
     * When stock is reserved:
     * - Customer places order
     * - Payment being processed
     * - Stock held for this customer
     *
     * Changes:
     * - Increases when order placed (RESERVATION)
     * - Decreases when payment succeeds (commit to SALE)
     * - Decreases when payment fails (RELEASE)
     *
     * Validation:
     * - Cannot be negative
     * - Should always: reserved >= 0
     *
     * Database column: reserved_quantity INT NOT NULL DEFAULT 0
     *
     * Example: 15 (15 units held for pending orders)
     *
     * Why track separately?
     * - Know how much stock is "in limbo"
     * - Calculate true available stock
     * - Monitor order fulfillment pipeline
     * - Prevent overselling
     */
    @Column(name = "reserved_quantity", nullable = false)
    @Builder.Default  // Default to 0 when using builder
    private Integer reservedQuantity = 0;

    /**
     * Total Quantity
     *
     * Total physical stock in warehouse.
     * Sum of available and reserved.
     *
     * Invariant:
     * total = available + reserved
     *
     * This should ALWAYS be true!
     *
     * Changes:
     * - Increases when new stock received (PURCHASE, RETURN)
     * - Decreases when stock leaves (SALE, DAMAGE)
     * - Adjusted manually (ADJUSTMENT)
     *
     * NOT affected by:
     * - RESERVATION (just moves from available to reserved)
     * - RELEASE (just moves from reserved to available)
     *
     * Database column: total_quantity INT NOT NULL
     *
     * Example: 100 (100 units in warehouse)
     *
     * Usage:
     * - Reordering decisions
     * - Inventory value calculations
     * - Physical count reconciliation
     * - Warehouse space planning
     */
    @Column(name = "total_quantity", nullable = false)
    private Integer totalQuantity;

    /**
     * Low Stock Threshold
     *
     * Minimum stock level before reordering is needed.
     * When available stock falls below this, alert should be triggered.
     *
     * Configuration:
     * - Can be set per product
     * - Different products have different thresholds
     * - High-demand products: higher threshold
     * - Slow-moving products: lower threshold
     *
     * Uses:
     * - Automated reordering triggers
     * - Admin dashboard alerts
     * - Inventory planning
     *
     * Example values:
     * - Popular items: 50 units
     * - Regular items: 20 units
     * - Slow movers: 5 units
     *
     * Database column: low_stock_threshold INT DEFAULT 10
     *
     * Example: 10 (alert when stock falls below 10 units)
     *
     * Alert logic:
     * if (inventory.getAvailableQuantity() < inventory.getLowStockThreshold()) {
     *     sendLowStockAlert(inventory.getProductId());
     * }
     */
    @Column(name = "low_stock_threshold")
    @Builder.Default  // Default to 10 when using builder
    private Integer lowStockThreshold = 10;

    /**
     * Created At
     *
     * When this inventory record was created.
     * Usually when product was first added.
     *
     * Database column: created_at DATETIME NOT NULL
     */
    @Column(name = "created_at", nullable = false, updatable = false)
    private LocalDateTime createdAt;

    /**
     * Updated At
     *
     * When this inventory record was last modified.
     * Updated on every stock change.
     *
     * Database column: updated_at DATETIME NOT NULL
     */
    @Column(name = "updated_at", nullable = false)
    private LocalDateTime updatedAt;

    /**
     * Pre-Persist Callback
     *
     * Called automatically before INSERT.
     * Sets timestamps and initializes reserved quantity.
     */
    @PrePersist
    protected void onCreate() {
        LocalDateTime now = LocalDateTime.now();
        createdAt = now;
        updatedAt = now;

        // Initialize reserved quantity if null
        if (reservedQuantity == null) {
            reservedQuantity = 0;
        }

        // Initialize low stock threshold if null
        if (lowStockThreshold == null) {
            lowStockThreshold = 10;
        }
    }

    /**
     * Pre-Update Callback
     *
     * Called automatically before UPDATE.
     * Updates the timestamp.
     */
    @PreUpdate
    protected void onUpdate() {
        updatedAt = LocalDateTime.now();
    }

    /**
     * Business Logic Methods
     * ======================
     */

    /**
     * Check if stock is low
     *
     * Returns true if available quantity is below threshold.
     *
     * @return true if stock is low, false otherwise
     */
    public boolean isLowStock() {
        return availableQuantity < lowStockThreshold;
    }

    /**
     * Check if stock is available
     *
     * Returns true if any units are available for sale.
     *
     * @return true if available > 0
     */
    public boolean hasAvailableStock() {
        return availableQuantity > 0;
    }

    /**
     * Check if sufficient stock available
     *
     * Returns true if requested quantity is available.
     *
     * @param quantity Quantity requested
     * @return true if sufficient stock available
     */
    public boolean hasSufficientStock(int quantity) {
        return availableQuantity >= quantity;
    }

    /**
     * Reserve Stock
     *
     * Moves stock from available to reserved.
     * Called when order is placed.
     *
     * @param quantity Quantity to reserve
     * @throws IllegalStateException if insufficient stock
     */
    public void reserveStock(int quantity) {
        // Validate sufficient stock
        if (quantity > availableQuantity) {
            throw new IllegalStateException(
                "Insufficient stock. Available: " + availableQuantity +
                ", Requested: " + quantity
            );
        }

        // Move from available to reserved
        availableQuantity -= quantity;
        reservedQuantity += quantity;

        // Total unchanged (no stock left warehouse)
        // Invariant check
        assert totalQuantity == availableQuantity + reservedQuantity;
    }

    /**
     * Release Reservation
     *
     * Moves stock from reserved back to available.
     * Called when payment fails or order cancelled.
     *
     * @param quantity Quantity to release
     * @throws IllegalStateException if trying to release more than reserved
     */
    public void releaseReservation(int quantity) {
        // Validate not releasing more than reserved
        if (quantity > reservedQuantity) {
            throw new IllegalStateException(
                "Cannot release more than reserved. Reserved: " + reservedQuantity +
                ", Requested: " + quantity
            );
        }

        // Move from reserved to available
        reservedQuantity -= quantity;
        availableQuantity += quantity;

        // Total unchanged
        // Invariant check
        assert totalQuantity == availableQuantity + reservedQuantity;
    }

    /**
     * Commit Reservation (Complete Sale)
     *
     * Removes stock from both reserved and total.
     * Called when payment succeeds and stock leaves warehouse.
     *
     * @param quantity Quantity to commit
     * @throws IllegalStateException if trying to commit more than reserved
     */
    public void commitReservation(int quantity) {
        // Validate not committing more than reserved
        if (quantity > reservedQuantity) {
            throw new IllegalStateException(
                "Cannot commit more than reserved. Reserved: " + reservedQuantity +
                ", Requested: " + quantity
            );
        }

        // Remove from reserved
        reservedQuantity -= quantity;

        // Remove from total (stock left warehouse)
        totalQuantity -= quantity;

        // Available unchanged (was already reduced during reservation)
        // Invariant check
        assert totalQuantity == availableQuantity + reservedQuantity;
    }

    /**
     * Add Stock
     *
     * Increases total and available stock.
     * Called for PURCHASE, RETURN.
     *
     * @param quantity Quantity to add
     */
    public void addStock(int quantity) {
        // Add to both total and available
        totalQuantity += quantity;
        availableQuantity += quantity;

        // Reserved unchanged
        // Invariant check
        assert totalQuantity == availableQuantity + reservedQuantity;
    }

    /**
     * Reduce Stock
     *
     * Decreases total and available stock.
     * Called for DAMAGE.
     *
     * @param quantity Quantity to reduce
     * @throws IllegalStateException if reducing more than available
     */
    public void reduceStock(int quantity) {
        // Validate not reducing more than available
        if (quantity > availableQuantity) {
            throw new IllegalStateException(
                "Cannot reduce more than available. Available: " + availableQuantity +
                ", Requested: " + quantity
            );
        }

        // Remove from both total and available
        totalQuantity -= quantity;
        availableQuantity -= quantity;

        // Reserved unchanged
        // Invariant check
        assert totalQuantity == availableQuantity + reservedQuantity;
    }

    /**
     * Adjust Stock
     *
     * Manually adjusts stock to match physical count.
     * Can increase or decrease.
     *
     * @param newTotalQuantity New total quantity from physical count
     */
    public void adjustStock(int newTotalQuantity) {
        // Calculate difference
        int difference = newTotalQuantity - totalQuantity;

        // Update total
        totalQuantity = newTotalQuantity;

        // Adjust available by same amount
        // (reserved should remain as-is)
        availableQuantity += difference;

        // Invariant check
        assert totalQuantity == availableQuantity + reservedQuantity;
    }

    /**
     * Validate Invariants
     *
     * Checks that inventory state is consistent.
     * Should be called after any stock change.
     *
     * @throws IllegalStateException if invariants violated
     */
    public void validateInvariants() {
        // Total must equal available + reserved
        if (totalQuantity != availableQuantity + reservedQuantity) {
            throw new IllegalStateException(
                "Inventory invariant violated! Total: " + totalQuantity +
                ", Available: " + availableQuantity +
                ", Reserved: " + reservedQuantity
            );
        }

        // Quantities cannot be negative
        if (totalQuantity < 0 || availableQuantity < 0 || reservedQuantity < 0) {
            throw new IllegalStateException(
                "Negative quantities not allowed! Total: " + totalQuantity +
                ", Available: " + availableQuantity +
                ", Reserved: " + reservedQuantity
            );
        }
    }
}
